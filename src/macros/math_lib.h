//////////////////////////////////////////////////////////////////////////////////////
/// математическая библиотека для работы с векторно-матрично-кватернионной алгеброй //
//////////////////////////////////////////////////////////////////////////////////////

#ifndef _MATH_LIB_H_
#define _MATH_LIB_H_

#include <math.h>
#include <stdlib.h>

//////////////////////////////////////////////////////////////////////////////////////
/// КОНСТАНТЫ

#define _PI       3.14159265358979323846264
#define _TWO_PI   6.28318530717958647692528
#define _HALF_PI  1.570796326719489661923132
#define _QUAR_PI  0.78539816339744830961566
#define _THIRD_PI 1.04719755119659774615421

#define _D2R  (_PI/180.) // перевод из градусов в радианы
#define _R2D  (180./_PI) // перевод из радиан в градусы
#define _D2M  (60.)
#define _D2S  (3600.)
#define _M2S  (60.)
#define _S2M  (1./60.)
#define _S2D  (1./3600.)
#define _M2D  (1./60.)

//////////////////////////////////////////////////////////////////////////////////////
/// ОБЩИЕ МАТЕМАТИЧЕСКИЕ МАКРОСЫ

#define _SQR(w)  ((w)*(w))         // квадрат числа
#define _CUBE(w) ((w)*(w)*(w))     // куб числа
#define _QTR(w)  ((w)*(w)*(w)*(w)) // 4 степень числа

//////////////////////////////////////////////////////////////////////////////////////
/// ТИПЫ ДАННЫХ

// типы целочисленных данных
typedef char               int8;
typedef unsigned char      uint8;
typedef short              int16;
typedef unsigned short     uint16;
typedef long               int32;
typedef unsigned long      uint32;
typedef long long          int64;
typedef unsigned long long uint64;

// тип данных вектор 3х1
typedef double vector3[3];
// тип данных матрицы 3х3
typedef double matrix33[9];
// тип данных кватернион
typedef struct {
    double scr;
    vector3 vct;
} quaternion;

//////////////////////////////////////////////////////////////////////////////////////
/// ПЕЧАТЬ В БУФЕР

#define _V_PRINT(_textbefore, _v, _textafter) printf("%s[%f; %f; %f]%s\n", _textbefore, _v[0], _v[1], _v[2], _textafter)

//////////////////////////////////////////////////////////////////////////////////////
/// ОПЕРАЦИИ С ВЕКТОРАМИ 3х1 И МАТРИЦАМИ 3х3

// заполнение вектора значениями
#define _V_FILL(v_res, n1, n2, n3) (v_res[0] = (n1), v_res[1] = (n2), v_res[2] = (n3))
// обнуление вектора
#define _V_ZERO(v_res) _V_FILL(v_res, 0., 0., 0.)
// приравнивание векторов
#define _V_EQUATE(v_res, v) _V_FILL(v_res, v[0], v[1], v[2])
// сложение 2 векторов
#define _V_SUM(v_res, v_1, v_2) (v_res[0] = v_1[0] + v_2[0], \
                                 v_res[1] = v_1[1] + v_2[1], \
                                 v_res[2] = v_1[2] + v_2[2])
// сложение 3 векторов
#define _V_3SUM(v_res, v_1, v_2, v_3) (v_res[0] = v_1[0] + v_2[0] + v_3[0], \
                                       v_res[1] = v_1[1] + v_2[1] + v_3[1], \
                                       v_res[2] = v_1[2] + v_2[2] + v_3[2])
// сложение 4 векторов
#define _V_4SUM(v_res, v_1, v_2, v_3, v_4) (v_res[0] = v_1[0] + v_2[0] + v_3[0] + v_4[0], \
                                            v_res[1] = v_1[1] + v_2[1] + v_3[1] + v_4[1], \
                                            v_res[2] = v_1[2] + v_2[2] + v_3[2] + v_4[2])
// вычитание 2 векторов
#define _V_SUB(v_res, v_1, v_2) (v_res[0] = v_1[0] - v_2[0], \
                                 v_res[1] = v_1[1] - v_2[1], \
                                 v_res[2] = v_1[2] - v_2[2])
// вычитание 3 векторов
#define _V_3SUB(v_res, v_1, v_2, v_3) (v_res[0] = v_1[0] - v_2[0] - v_3[0], \
                                       v_res[1] = v_1[1] - v_2[1] - v_3[1], \
                                       v_res[2] = v_1[2] - v_2[2] - v_3[2])
// умножение вектора на число
#define _VN_MULT(v_res, v, n) (v_res[0] = v[0]*(n), \
                               v_res[1] = v[1]*(n), \
                               v_res[2] = v[2]*(n))
// деление вектора на число
#define _VN_DIV(v_res, v, n) (v_res[0] = v[0]/(n), \
                              v_res[1] = v[1]/(n), \
                              v_res[2] = v[2]/(n))
// поэлементное произведение векторов
#define _V_EMULT(v_res, v_1, v_2) (v_res[0] = v_1[0]*v_2[0], \
                                   v_res[1] = v_1[1]*v_2[1], \
                                   v_res[2] = v_1[2]*v_2[2])
// поэлементное деление векторов
#define _V_EDIV(v_res, v_1, v_2) (v_res[0] = v_1[0]/v_2[0], \
                                  v_res[1] = v_1[1]/v_2[1], \
                                  v_res[2] = v_1[2]/v_2[2])
// скалярное произведение векторов
#define _V_DOT(v_1, v_2) (v_1[0]*v_2[0] + v_1[1]*v_2[1] + v_1[2]*v_2[2])
// векторное произведение
#define _V_CROSS(v_res, v_1, v_2) (v_res[0] = v_1[1]*v_2[2] - v_1[2]*v_2[1], \
                                   v_res[1] = v_1[2]*v_2[0] - v_1[0]*v_2[2], \
                                   v_res[2] = v_1[0]*v_2[1] - v_1[1]*v_2[0])
// умножение тензора, построенного из вектора, на вектор
#define _TV_MULT(v_res, t, v) (v_res[0] = - t[2]*v[1] + t[1]*v[2], \
                               v_res[1] =   t[2]*v[0] - t[0]*v[2], \
                               v_res[2] = - t[1]*v[0] + t[0]*v[1])
// квадрат модуля вектора
#define _V_NORM_2(v) (_SQR(v[0]) + _SQR(v[1]) + _SQR(v[2]))
// модуль вектора
#define _V_NORM(v) sqrt(_V_NORM_2(v))

// заполнение матрицы значениями
#define _M_FILL(m, m11, m12, m13, m21, m22, m23, m31, m32, m33) (m[0] = m11, m[1] = m12, m[2] = m13, \
                                                                 m[3] = m21, m[4] = m22, m[5] = m23, \
                                                                 m[6] = m31, m[7] = m32, m[8] = m33)
// единичная матрица
#define _M_UNI(m) _M_FILL(m, 1., 0., 0., 0., 1., 0., 0., 0., 1.)
// нулевая матрица
#define _M_ZERO(m) _M_FILL(m, 0., 0., 0., 0., 0., 0., 0., 0., 0.)
// приравнять 2 матрицы
#define _M_EQUATE(m_res, m) _M_FILL(m_res, m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8])
// транспонирование матрицы
#define _M_TRAN(m_res, m) (m_res[0] = m[0], m_res[1] = m[3], m_res[2] = m[6], \
                           m_res[3] = m[1], m_res[4] = m[4], m_res[5] = m[7], \
                           m_res[6] = m[2], m_res[7] = m[5], m_res[8] = m[8])
// определетиль матрицы
#define _M_DET(m) (- m[2]*m[4]*m[6] + m[1]*m[5]*m[6] + m[2]*m[3]*m[7] - m[0]*m[5]*m[7] - m[1]*m[3]*m[8] + m[0]*m[4]*m[8])
// сложение 2 матриц
#define _M_SUM(m_res, m_1, m_2) (m_res[0] = m_1[0] + m_2[0], m_res[1] = m_1[1] + m_2[1], m_res[2] = m_1[2] + m_2[2], \
                                 m_res[3] = m_1[3] + m_2[3], m_res[4] = m_1[4] + m_2[4], m_res[5] = m_1[5] + m_2[5], \
                                 m_res[6] = m_1[6] + m_2[6], m_res[7] = m_1[7] + m_2[7], m_res[8] = m_1[8] + m_2[8])
// сложение 3 матриц
#define _M_3SUM(m_res, m_1, m_2, m_3) (m_res[0] = m_1[0] + m_2[0] + m_3[0], m_res[1] = m_1[1] + m_2[1] + m_3[1], m_res[2] = m_1[2] + m_2[2] + m_3[2], \
                                       m_res[3] = m_1[3] + m_2[3] + m_3[3], m_res[4] = m_1[4] + m_2[4] + m_3[4], m_res[5] = m_1[5] + m_2[5] + m_3[5], \
                                       m_res[6] = m_1[6] + m_2[6] + m_3[6], m_res[7] = m_1[7] + m_2[7] + m_3[7], m_res[8] = m_1[8] + m_2[8] + m_3[8])
// сложение 2 матриц
#define _M_SUB(m_res, m_1, m_2) (m_res[0] = m_1[0] - m_2[0], m_res[1] = m_1[1] - m_2[1], m_res[2] = m_1[2] - m_2[2], \
                                 m_res[3] = m_1[3] - m_2[3], m_res[4] = m_1[4] - m_2[4], m_res[5] = m_1[5] - m_2[5], \
                                 m_res[6] = m_1[6] - m_2[6], m_res[7] = m_1[7] - m_2[7], m_res[8] = m_1[8] - m_2[8])
// произведение матрицы на число
#define _MN_MULT(m_res, m_1, n) (m_res[0] = m_1[0]*(n), m_res[1] = m_1[1]*(n), m_res[2] = m_1[2]*(n), \
                                 m_res[3] = m_1[3]*(n), m_res[4] = m_1[4]*(n), m_res[5] = m_1[5]*(n), \
                                 m_res[6] = m_1[6]*(n), m_res[7] = m_1[7]*(n), m_res[8] = m_1[8]*(n))
// деление матрицы на число
#define _MN_DIV(m_res, m_1, n) (m_res[0] = m_1[0]/(n), m_res[1] = m_1[1]/(n), m_res[2] = m_1[2]/(n), \
                                m_res[3] = m_1[3]/(n), m_res[4] = m_1[4]/(n), m_res[5] = m_1[5]/(n), \
                                m_res[6] = m_1[6]/(n), m_res[7] = m_1[7]/(n), m_res[8] = m_1[8]/(n))
// произведение матрицы на вектор
#define _MV_MULT(v_res, m, v) (v_res[0] = m[0]*v[0] + m[1]*v[1] + m[2]*v[2], \
                               v_res[1] = m[3]*v[0] + m[4]*v[1] + m[5]*v[2], \
                               v_res[2] = m[6]*v[0] + m[7]*v[1] + m[8]*v[2])
// произведение транспонированной матрицы на вектор
#define _MV_TMULT(v_res, m, v) (v_res[0] = m[0]*v[0] + m[3]*v[1] + m[6]*v[2], \
                                v_res[1] = m[1]*v[0] + m[4]*v[1] + m[7]*v[2], \
                                v_res[2] = m[2]*v[0] + m[5]*v[1] + m[8]*v[2])
// поэлементное произведение 2 матриц
#define _M_EMULT(m_res, m_1, m_2) (m_res[0] = m_1[0]*m_2[0], m_res[1] = m_1[1]*m_2[1], m_res[2] = m_1[2]*m_2[2], \
                                   m_res[3] = m_1[3]*m_2[3], m_res[4] = m_1[4]*m_2[4], m_res[5] = m_1[5]*m_2[5], \
                                   m_res[6] = m_1[6]*m_2[6], m_res[7] = m_1[7]*m_2[7], m_res[8] = m_1[8]*m_2[8])
// произведение 2 матриц
#define _M_MULT(m_res, m_1, m_2) (m_res[0] = m_1[0]*m_2[0] + m_1[1]*m_2[3] + m_1[2]*m_2[6], \
                                  m_res[1] = m_1[0]*m_2[1] + m_1[1]*m_2[4] + m_1[2]*m_2[7], \
                                  m_res[2] = m_1[0]*m_2[2] + m_1[1]*m_2[5] + m_1[2]*m_2[8], \
                                  m_res[3] = m_1[3]*m_2[0] + m_1[4]*m_2[3] + m_1[5]*m_2[6], \
                                  m_res[4] = m_1[3]*m_2[1] + m_1[4]*m_2[4] + m_1[5]*m_2[7], \
                                  m_res[5] = m_1[3]*m_2[2] + m_1[4]*m_2[5] + m_1[5]*m_2[8], \
                                  m_res[6] = m_1[6]*m_2[0] + m_1[7]*m_2[3] + m_1[8]*m_2[6], \
                                  m_res[7] = m_1[6]*m_2[1] + m_1[7]*m_2[4] + m_1[8]*m_2[7], \
                                  m_res[8] = m_1[6]*m_2[2] + m_1[7]*m_2[5] + m_1[8]*m_2[8])
// произведение транспонированной матрицы на матрицу
#define _M_T1MULT(m_res, m_1, m_2) (m_res[0] = m_1[0]*m_2[0] + m_1[3]*m_2[3] + m_1[6]*m_2[6], \
                                    m_res[1] = m_1[0]*m_2[1] + m_1[3]*m_2[4] + m_1[6]*m_2[7], \
                                    m_res[2] = m_1[0]*m_2[2] + m_1[3]*m_2[5] + m_1[6]*m_2[8], \
                                    m_res[3] = m_1[1]*m_2[0] + m_1[4]*m_2[3] + m_1[7]*m_2[6], \
                                    m_res[4] = m_1[1]*m_2[1] + m_1[4]*m_2[4] + m_1[7]*m_2[7], \
                                    m_res[5] = m_1[1]*m_2[2] + m_1[4]*m_2[5] + m_1[7]*m_2[8], \
                                    m_res[6] = m_1[2]*m_2[0] + m_1[5]*m_2[3] + m_1[8]*m_2[6], \
                                    m_res[7] = m_1[2]*m_2[1] + m_1[5]*m_2[4] + m_1[8]*m_2[7], \
                                    m_res[8] = m_1[2]*m_2[2] + m_1[5]*m_2[5] + m_1[8]*m_2[8])
// произведение матрицы на транспонированную матрицу
#define _M_T2MULT(m_res, m_1, m_2) (m_res[0] = m_1[0]*m_2[0] + m_1[1]*m_2[1] + m_1[2]*m_2[2], \
                                    m_res[1] = m_1[0]*m_2[3] + m_1[1]*m_2[4] + m_1[2]*m_2[5], \
                                    m_res[2] = m_1[0]*m_2[6] + m_1[1]*m_2[7] + m_1[2]*m_2[8], \
                                    m_res[3] = m_1[3]*m_2[0] + m_1[4]*m_2[1] + m_1[5]*m_2[2], \
                                    m_res[4] = m_1[3]*m_2[3] + m_1[4]*m_2[4] + m_1[5]*m_2[5], \
                                    m_res[5] = m_1[3]*m_2[6] + m_1[4]*m_2[7] + m_1[5]*m_2[8], \
                                    m_res[6] = m_1[6]*m_2[0] + m_1[7]*m_2[1] + m_1[8]*m_2[2], \
                                    m_res[7] = m_1[6]*m_2[3] + m_1[7]*m_2[4] + m_1[8]*m_2[5], \
                                    m_res[8] = m_1[6]*m_2[6] + m_1[7]*m_2[7] + m_1[8]*m_2[8])
// произведение транспонированной матрицы на транспонированную матрицу
#define _M_TTMULT(m_res, m_1, m_2) (m_res[0] = m_1[0]*m_2[0] + m_1[3]*m_2[1] + m_1[6]*m_2[2], \
                                    m_res[1] = m_1[0]*m_2[3] + m_1[3]*m_2[4] + m_1[6]*m_2[5], \
                                    m_res[2] = m_1[0]*m_2[6] + m_1[3]*m_2[7] + m_1[6]*m_2[8], \
                                    m_res[3] = m_1[1]*m_2[0] + m_1[4]*m_2[1] + m_1[7]*m_2[2], \
                                    m_res[4] = m_1[1]*m_2[3] + m_1[4]*m_2[4] + m_1[7]*m_2[5], \
                                    m_res[5] = m_1[1]*m_2[6] + m_1[4]*m_2[7] + m_1[7]*m_2[8], \
                                    m_res[6] = m_1[2]*m_2[0] + m_1[5]*m_2[1] + m_1[8]*m_2[2], \
                                    m_res[7] = m_1[2]*m_2[3] + m_1[5]*m_2[4] + m_1[8]*m_2[5], \
                                    m_res[8] = m_1[2]*m_2[6] + m_1[5]*m_2[7] + m_1[8]*m_2[8])
// произведения тензора, построенного из вектора, на матрицу
#define _TM_MULT(m_res, t, m) (m_res[0] = - t[2]*m[3] + t[1]*m[6], \
                               m_res[1] = - t[2]*m[4] + t[1]*m[7], \
                               m_res[2] = - t[2]*m[5] + t[1]*m[8], \
                               m_res[3] =   t[2]*m[0] - t[0]*m[6], \
                               m_res[4] =   t[2]*m[1] - t[0]*m[7], \
                               m_res[5] =   t[2]*m[2] - t[0]*m[8], \
                               m_res[6] = - t[1]*m[0] + t[0]*m[3], \
                               m_res[7] = - t[1]*m[1] + t[0]*m[4], \
                               m_res[8] = - t[1]*m[2] + t[0]*m[5])
// произведение матрицы на тензор, построенный из вектора
#define _MT_MULT(m_res, m, t) (m_res[0] =   m[1]*t[2] - m[2]*t[1], \
                               m_res[1] = - m[0]*t[2] + m[2]*t[0], \
                               m_res[2] =   m[0]*t[1] - m[1]*t[0], \
                               m_res[3] =   m[4]*t[2] - m[5]*t[1], \
                               m_res[4] = - m[3]*t[2] + m[5]*t[0], \
                               m_res[5] =   m[3]*t[1] - m[4]*t[0], \
                               m_res[6] =   m[7]*t[2] - m[8]*t[1], \
                               m_res[7] = - m[6]*t[2] + m[8]*t[0], \
                               m_res[8] =   m[6]*t[1] - m[7]*t[0])
// произведение тензора на тензор
#define _TT_MULT(m_res, t1, t2) (m_res[0] = - t1[1]*t2[1] - t1[2]*t2[2], \
                                 m_res[1] =   t1[1]*t2[0] , \
                                 m_res[2] =   t1[2]*t2[0] , \
                                 m_res[3] =   t1[0]*t2[1], \
                                 m_res[4] = - t1[0]*t2[0] - t1[2]*t2[2], \
                                 m_res[5] =   t1[2]*t2[1], \
                                 m_res[6] =   t1[0]*t2[2], \
                                 m_res[7] =   t1[1]*t2[2], \
                                 m_res[8] = - t1[0]*t2[0] - t1[1]*t2[1])
// выделение строки матрицы в вектор (row - номер строки, от 0 до 2)
#define _M_ROW(v, m, row) (v[0] = m[row*3], \
                           v[1] = m[row*3+1], \
                           v[2] = m[row*3+2])
// выделение столбца матрицы в вектор (col - номер строки, от 0 до 2)
#define _M_COL(v, m, col) (v[0] = m[col], \
                           v[1] = m[col+3], \
                           v[2] = m[col+6])
// обратная матрица
#define _M_INV(m_res, m) {double __m_det__ = _M_DET(m); \
                          m_res[0] = (m[4]*m[8] - m[5]*m[7])/__m_det__; \
                          m_res[1] = (m[2]*m[7] - m[1]*m[8])/__m_det__; \
                          m_res[2] = (m[1]*m[5] - m[2]*m[4])/__m_det__; \
                          m_res[3] = (m[7]*m[6] - m[3]*m[8])/__m_det__; \
                          m_res[4] = (m[0]*m[8] - m[2]*m[6])/__m_det__; \
                          m_res[5] = (m[2]*m[3] - m[0]*m[5])/__m_det__; \
                          m_res[6] = (m[3]*m[7] - m[4]*m[6])/__m_det__; \
                          m_res[7] = (m[1]*m[6] - m[0]*m[7])/__m_det__; \
                          m_res[8] = (m[0]*m[4] - m[1]*m[3])/__m_det__;}
// преобразование кватерниона в матрицу направляющих косинусов
#define _M_FROMQ(m_res, q) (m_res[0] = 1. - 2.*(_SQR(q.vct[1]) + _SQR(q.vct[2])), \
                            m_res[1] = 2.*(q.vct[0]*q.vct[1] - q.vct[2]*q.scr), \
                            m_res[2] = 2.*(q.vct[0]*q.vct[2] + q.vct[1]*q.scr), \
                            m_res[3] = 2.*(q.vct[0]*q.vct[1] + q.vct[2]*q.scr), \
                            m_res[4] = 1. - 2.*(_SQR(q.vct[0]) + _SQR(q.vct[2])), \
                            m_res[5] = 2.*(q.vct[1]*q.vct[2] - q.vct[0]*q.scr), \
                            m_res[6] = 2.*(q.vct[0]*q.vct[2] - q.vct[1]*q.scr), \
                            m_res[7] = 2.*(q.vct[1]*q.vct[2] + q.vct[0]*q.scr), \
                            m_res[8] = 1. - 2.*(_SQR(q.vct[0]) + _SQR(q.vct[1])))

//////////////////////////////////////////////////////////////////////////////////////
/// ОПЕРАЦИИ С КВАТЕРНИОНАМИ

// заполнение кватерниона значениями
#define _Q_FILL (q, scr, v1, v2, v3) (q.scr = (scr), _V_FILL(q.vct, v1, v2, v3))
// заполнение кватерниона скаляром и вектором
#define _Q_VFILL (q, scr, v) (q.scr = (scr), _V_EQUATE(q.vct, v))
// нулевой кватернион
#define _Q_ZERO (q) (_q.scr = 0., _V_ZERO(_q.vct))
// единичный кватернион
#define _Q_UNI (q) (_q.scr = 1., _V_ZERO(_q.vct))
// сложение 2 кватернионов
#define _Q_SUM (q_res, q1, q2) (q_res.scr = q1.scr + q2.scr, _V_SUM(q_res.vct, q1.vct, q2.vct))
// сложение 3 кватернионов
#define _Q_3SUM (q_res, q1, q2, q3) (q_res.scr = q1.scr + q2.scr + q3.scr, _V_3SUM(q_res.vct, q1.vct, q2.vct, q3.vct))
// сложение 4 кватернионов
#define _Q_4SUM (q_res, q1, q2, q3, q4) (q_res.scr = q1.scr + q2.scr + q3.scr + q4.scr, _V_4SUM(q_res.vct, q1.vct, q2.vct, q3.vct, q4.vct))
// вычитание кватернионов
#define _Q_SUB (q_res, q1, q2) (q_res.scr = q1.scr - q2.scr, _V_SUB(q_res.vct, q1.vct, q2.vct))
// вычитание 3 кватернионов
#define _Q_3SUB (q_res, q1, q2, q3) (q_res.scr = q1.scr + q2.scr - q3.scr, _V_3SUB(q_res.vct, q1.vct, q2.vct, q3.vct))
// умножение кватерниона на число
#define _QN_MULT(q_res, q, n) (q.scr = q.scr*(n), _VN_MULT(q.vct, n))
// деление кватерниона на число
#define _QN_DIV(q_res, q, n) (q.scr = q.scr/(n), _VN_DIV(q.vct, n))
// произведение 2 кватернионов (умножение Грассмана)
#define _Q_MULT (q_res, q1, q2) (q_res.scr = q1.scr*q2.scr - _V_DOT(q1.vct, q2.vct), \
                                 q_res.vct[0] = q2.scr*q1.vct[0] + q1.scr*q2.vct[0] - q1.vct[2]*q2.vct[1] + q1.vct[1]*q2.vct[2], \
                                 q_res.vct[1] = q2.scr*q1.vct[1] + q1.scr*q2.vct[1] + q1.vct[2]*q2.vct[0] - q1.vct[0]*q2.vct[2], \
                                 q.res.vct[2] = q2.scr*q1.vct[2] + q1.scr*q2.vct[2] - q1.vct[1]*q2.vct[0] + q1.vct[0]*q2.vct[1])
// сопряженный кватернион
#define _Q_CONJ (q_res, q) _Q_FILL(q_res, q.scr, -q.vct[0], -q.vct[1], -q.vct[2])
// квадрат нормы кватерниона
#define _Q_NORM_2 (q) _SQR(q.scr) + _V_NORM_2(q.vct)
// норма кватерниона
#define _Q_NORM (q) sqrt(_Q_NORM_2(q))
// обращение кватерниона по умножению
#define _Q_INV (0, q) {double __q_norm2__; \
                           __q_norm2__ = _Q_NORM_2(q); \
                           q_res.scr = q.scr/__q_norm2__; \
                           _V_FILL(q_res.vct, - q.vct[0]/__q_norm2__, - q.vct[1]/__q_norm2__, - q.vct[2]/__q_norm2__);}
// скалярное произведение кватренионов
#define _Q_DOT(q_res, q1, q2) (q_res.scr = q1.scr*q2.scr + _V_DOT(q1.vct, q2.vct), _V_ZERO(q_res.vct))
// аргумент кватерниона
#define _Q_ARG(q) atan2(q.scr, _V_NORM(q.vct))
// преобразование матрицы направляющих косинусов в кватернион
#define _Q_FROMM (q_res, m) {double __t__, __s__; \
                             __t__ = m[0] + m[4] + m[8]; \
                             if (__t__ > 0.) { \
                                 __s__ = 0.5/sqrt(__t__); \
                                 _Q_FILL(q_res, 0.25/__s__, (m[7] - m[5])/__s__, (m[2] - m[6])/__s__, (m[3] - m[1])/__s__); \
                             } else { \
                                 if ((m[0] >= m[4]) && (m[0] >= m[8])) { \
                                     __s__ = 2*sqrt(m[0] - m[4] - m[8]); \
                                     _Q_FILL(q_res, (m[5] + m[7])/__s__, 0.5/__s__, (m[1] + m[3])/__s__, (m[2] + m[6])/__s__); \
                                 } \
                                 if ((m[4] > m[0]) && (m[4] >= m[8])) { \
                                     __s__ = 2*sqrt(m[4] - m[0] - m[8]); \
                                     _Q_FILL(q_res, (m[2] + m[6])/__s__, (m[1] + m[3])/__s__, 0.5/__s__, (m[5] + m[7])/__s__); \
                                 } \
                                 if ((m[8] > m[4]) && (m[8] >= m[0])) { \
                                     __s__ = 2*sqrt(m[8] - m[4] - m[0]); \
                                     _Q_FILL(q_res, (m[1] + m[3])/__s__, (m[2] + m[6])/__s__, (m[5] + m[7])/__s__, 0.5/__s__); \
                                 } \
                             }}


#endif // _MATH_LIB_H_

